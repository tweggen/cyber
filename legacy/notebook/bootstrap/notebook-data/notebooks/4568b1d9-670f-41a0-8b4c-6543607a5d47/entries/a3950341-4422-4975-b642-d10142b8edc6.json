{
  "id": "a3950341-4422-4975-b642-d10142b8edc6",
  "content": "DECISION 1-2: Causal Position Assignment Implementation\n\nAUTHOR: agent-causal\n\nDESIGN DECISIONS:\n\n1. SERVICE LOCATION:\n   - Create crates/notebook-store/src/causal.rs as new module\n   - Export via lib.rs as pub mod causal and CausalPositionService\n   - Service operates on PgPool reference, not Store instance (decoupled design)\n\n2. ATOMICITY STRATEGY:\n   - Use single SQL transaction with row-level locking\n   - SELECT ... FOR UPDATE on notebooks table or use UPDATE RETURNING for atomic increment\n   - All activity context computation happens within same transaction\n   - This ensures sequence numbers are strictly monotonic with no gaps\n\n3. SEQUENCE COUNTER APPROACH:\n   - Option A: Add next_sequence column to notebooks table (requires migration)\n   - Option B: Use MAX(sequence) + 1 with row locking on notebooks table\n   - CHOSEN: Option B to avoid schema changes (migration 002 already deployed)\n   - The unique_notebook_sequence constraint ensures no duplicates\n   - Row lock on notebook ensures serialized sequence assignment\n\n4. ACTIVITY CONTEXT COMPUTATION:\n   - entries_since_last_by_author: COUNT entries WHERE sequence > author_last_seq\n   - total_notebook_entries: COUNT(*) entries in notebook\n   - recent_entropy: SUM(catalog_shift) from last 10 entries JSONB\n   - All computed in single transaction with notebook lock held\n\n5. CONCURRENT WRITE HANDLING:\n   - PostgreSQL row-level locking (SELECT FOR UPDATE on notebook row)\n   - Serialized access ensures no race conditions\n   - If two writes conflict, one waits, other proceeds\n   - No application-level locking needed\n\n6. FUNCTION SIGNATURE:\n   - CausalPositionService::assign_position(pool: &PgPool, notebook_id: NotebookId, author_id: AuthorId) -> Result<CausalPosition, StoreError>\n   - Returns CausalPosition from notebook_core types\n   - Uses existing StoreError for error handling\n\n7. TESTING APPROACH:\n   - Unit tests for ActivityContext computation logic\n   - Integration tests (marked with #[cfg(feature = \"integration-tests\")]) for:\n     - Sequential writes produce monotonic sequences\n     - Concurrent writes are serialized correctly\n     - ActivityContext values are accurate\n\nRATIONALE:\n- Using row lock on notebooks table ensures serialization without schema changes\n- Computing all values in one transaction ensures consistency\n- Decoupled from Store to allow separate evolution\n- Uses existing types from notebook-core for compatibility",
  "content_type": "text/plain",
  "topic": "decision 1-2",
  "references": [
    "203e20bf-7bc0-4128-a9d3-bd85f4d99c8e",
    "46ee8ade-fba4-4238-a0fd-27a1a838d8fa",
    "a533fd75-1485-4602-b9a2-3f9010390ced"
  ],
  "revision_of": null,
  "author": "agent-causal",
  "causal_position": {
    "sequence": 34,
    "activity_context": {
      "entries_since_last_by_author": 0,
      "total_notebook_entries": 33,
      "recent_entropy": 14.3
    }
  },
  "created": "2026-02-05T10:44:58.352100+00:00",
  "integration_cost": {
    "entries_revised": 0,
    "references_broken": 0,
    "catalog_shift": 0.0,
    "orphan": false
  }
}